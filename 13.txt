#include  < stdio . h > #include  < string . h > #include  < assert . h > #include  < conio . h > #include  < windows . h > typedef struct { unsigned short str_len ; unsigned short start_pos ;  } string_t ; typedef struct _st_entry_t { string_t the_string ; struct _st_entry_t * next ;  } st_entry_t ; typedef struct { string_t the_string ;  } tt_entry_t ; typedef struct { string_t the_string ; long character ;  } translated_string_t ; typedef struct { unsigned long code_num : 31 ; unsigned long data_compressed : 1 ;  } lzw_info_t ; #pragma pack (  ) enum { RCOK_DATA_COM = 1 , RCOK_DATA_UNC = 2 , RCFAILED =  - 1 ,  }  ; static union { st_entry_t lzw_string_table_entries [ MAX_ST_ENTRIES ]  ; tt_entry_t lzw_translation_table_entries [ MAX_ST_ENTRIES ]  ;  }  ; static union { st_entry_t * lzw_string_table [ MAX_STR_NUM ]  ; tt_entry_t * lzw_translation_table [ MAX_STR_NUM ]  ;  }  ; void set_bit ( unsigned char * bit_stream , const unsigned long offset_in_bits )  { unsigned long offset_in_bytes , offset_within_byte ; offset_in_bytes = offset_in_bits >> 3 ; offset_within_byte = offset_in_bits & 7 ;  *  ( bit_stream + offset_in_bytes )  |=  ( 1 << offset_within_byte )  ;  } void clear_bit ( unsigned char * bit_stream , const unsigned long offset_in_bits )  { unsigned long offset_in_bytes , offset_within_byte ; offset_in_bytes = offset_in_bits >> 3 ; offset_within_byte = offset_in_bits & 7 ;  *  ( bit_stream + offset_in_bytes )  &=  (  ~  ( 1 << offset_within_byte )  )  ;  } int read_bit ( unsigned char * bit_stream , const unsigned long offset_in_bits )  { unsigned long offset_in_bytes ; unsigned long offset_within_byte ; offset_in_bytes = offset_in_bits >> 3 ; offset_within_byte = offset_in_bits & 7 ; return (  (  *  ( unsigned long *  )  ( bit_stream + offset_in_bytes )  )  >> offset_within_byte )  & 1 ;  } void write_data_to_bs ( unsigned long * data , int bits_of_data , unsigned char * bit_stream , unsigned long & bit_offset )  { int i ; int n ; unsigned long _bit_offset = bit_offset , _bits_of_data = bits_of_data ; while ( bits_of_data > 0 )  { n = bits_of_data > 32 ? 32 : bits_of_data ; for ( i = 0 ; i < n ; i ++  )  { if (  (  (  * data )  >> i )  & 1 )  { set_bit ( bit_stream , bit_offset )  ;  } else { clear_bit ( bit_stream , bit_offset )  ;  } bit_offset ++  ;  } data ++  ; bits_of_data -= n ; if ( bits_of_data )  { assert ( 0 )  ;  }  } assert ( bit_offset - _bit_offset == _bits_of_data )  ;  } void write_char_to_bs ( const unsigned char data , unsigned char * bit_stream , unsigned long & bit_offset )  { unsigned long data_buff = data ; write_data_to_bs (  & data_buff , 8 , bit_stream , bit_offset )  ;  } void write_short_to_bs ( const unsigned short data , unsigned char * bit_stream , unsigned long & bit_offset )  { unsigned long data_buff = data ; write_data_to_bs (  & data_buff , 16 , bit_stream , bit_offset )  ;  } void read_data_from_bs ( void * data , int bits_of_data , unsigned char * bit_stream , unsigned long & bit_offset )  { int i ; int n ; while ( bits_of_data > 0 )  { n = bits_of_data > 8 ? 8 : bits_of_data ;  *  ( unsigned char *  ) data = 0 ; for ( i = 0 ; i < n ; i ++  )  { if ( read_bit ( bit_stream , bit_offset )  )  {  (  *  ( unsigned char *  ) data )  |=  ( 1 << i )  ;  } bit_offset ++  ;  } data =  (  ( unsigned char *  ) data )  + 1 ; bits_of_data -= n ;  }  } unsigned char read_char_from_bs ( unsigned char * bit_stream , unsigned long & bit_offset )  { unsigned char data ; read_data_from_bs (  & data , 8 , bit_stream , bit_offset )  ; return data ;  } unsigned short read_short_from_bs ( unsigned char * bit_stream , unsigned long & bit_offset )  { unsigned short data ; read_data_from_bs (  ( unsigned char *  )  & data , 16 , bit_stream , bit_offset )  ; return data ;  } int search_string_table ( unsigned char * data_buff , int string_num , st_entry_t *  * string_table , string_t * cur_str , st_entry_t *  * matched_entry = NULL )  { int length = cur_str -> str_len + 1 ; unsigned short index =  *  ( unsigned short *  )  ( data_buff + cur_str -> start_pos )  ; st_entry_t * next_entry = string_table [ index ]  ;  * matched_entry = NULL ; while ( next_entry )  { if ( length == next_entry -> the_string . str_len && memcmp ( data_buff + next_entry -> the_string . start_pos , data_buff + cur_str -> start_pos , length )  == 0 )  { if ( matched_entry )  {  * matched_entry = next_entry ;  } return ( int ) index ;  } next_entry = next_entry -> next ;  } return - 1 ;  } void addto_string_table ( unsigned char * data_buff , int & string_num , st_entry_t *  * string_table , st_entry_t * st_entries , string_t * cur_str )  { unsigned short index =  *  ( unsigned short *  )  ( data_buff + cur_str -> start_pos )  ; st_entries [ string_num ]  . the_string =  (  * cur_str )  ; st_entries [ string_num ]  . next = NULL ; st_entry_t * pre_entry = string_table [ index ]  ; if ( pre_entry )  { while ( pre_entry -> next )  { pre_entry = pre_entry -> next ;  } pre_entry -> next =  & st_entries [ string_num ]  ;  } else { string_table [ index ]  =  & st_entries [ string_num ]  ;  } string_num ++  ;  } void output_code ( unsigned short code , unsigned char * out_data_buffer , unsigned long & bit_offset )  { write_data_to_bs (  ( unsigned long *  )  & code , CODE_LENGTH , out_data_buffer , bit_offset )  ;  } int lzw_compress ( st_entry_t *  * string_table , st_entry_t * st_entries , unsigned char * in_data_buffer , int in_data_len , unsigned char * out_data_buffer , unsigned long * out_data_len )  { int ret_val = RCFAILED ; int string_num ; string_t cur_string ; st_entry_t * matched_entry ; int cur_pos ; unsigned long bit_offset ; st_entry_t *  * tmp_ptr1 = NULL ,  * tmp_ptr2 = NULL ; if ( in_data_len > MAX_CB_ONECE )  { goto err_out ;  } if (  ! string_table )  { tmp_ptr1 = new st_entry_t *  [ MAX_ST_ENTRIES ]  ; if (  ! tmp_ptr1 )  { goto err_out ;  } string_table = tmp_ptr1 ;  } if (  ! st_entries )  { tmp_ptr2 = new st_entry_t [ MAX_ST_ENTRIES ]  ; if (  ! tmp_ptr2 )  { goto err_out ;  } st_entries = tmp_ptr2 ;  } memset ( string_table , 0 , sizeof ( st_entry_t *  )  * MAX_STR_NUM )  ; memset ( st_entries , 0 , sizeof ( st_entry_t )  * MAX_ST_ENTRIES )  ; int cnt1 , cnt2 ; unsigned long total_string_length ; string_num = 0 ; bit_offset = 0 ; cur_string . start_pos = 0 ; cur_string . str_len = 1 ; cur_pos = 1 ; matched_entry = NULL ; cnt1 = 0 ; cnt2 = 0 ; total_string_length = 0 ; while ( 1 )  { st_entry_t * tmp_matched_entry ; if ( string_num + 256 >= MAXIMUM_CODE || bit_offset >=  ( unsigned long ) in_data_len * CODE_LENGTH )  { memcpy ( out_data_buffer , in_data_buffer , in_data_len )  ;  * out_data_len = in_data_len * 8 ; ret_val = RCOK_DATA_UNC ; goto cprs_fail ;  } if ( cur_pos < in_data_len && search_string_table ( in_data_buffer , string_num , string_table ,  & cur_string ,  & tmp_matched_entry )  >= 0 )  { cur_string . str_len ++  ; matched_entry = tmp_matched_entry ;  } else { unsigned short code ; if ( matched_entry )  { code = 256 +  ( unsigned short )  ( matched_entry - st_entries )  ; cnt1 ++  ; total_string_length += cur_string . str_len ; matched_entry = NULL ;  } else { code =  ( unsigned short ) in_data_buffer [ cur_string . start_pos ]  ; cnt2 ++  ;  } dbg_print ( "byte offset=%d, " , cur_string . start_pos )  ; dbg_print ( "code=%d, string length=%d\n" , code , cur_string . str_len )  ; output_code ( code , out_data_buffer , bit_offset )  ; cur_string . str_len ++  ; addto_string_table ( in_data_buffer , string_num , string_table , st_entries ,  & cur_string )  ; cur_string . start_pos = cur_pos ; cur_string . str_len = 1 ; if ( cur_pos >= in_data_len )  { break ;  }  } assert ( bit_offset ==  ( unsigned long )  ( cnt1 + cnt2 )  * CODE_LENGTH )  ; cur_pos ++  ;  }  * out_data_len = bit_offset ; ret_val = RCOK_DATA_COM ; err_out : cprs_fail : if ( tmp_ptr1 )  { delete [  ] tmp_ptr1 ;  } if ( tmp_ptr2 )  { delete [  ] tmp_ptr2 ;  } return ret_val ;  } int search_translation_table ( tt_entry_t *  * translation_table , unsigned short code )  { if ( code < 256 || translation_table [ code - 256 ]  )  { return 1 ;  } else { return - 1 ;  }  } void translate_code ( tt_entry_t *  * translation_table , unsigned short code , translated_string_t & cur_str )  { if ( code < 256 )  { cur_str . the_string . start_pos = 0 ; cur_str . the_string . str_len = 0 ; cur_str . character =  ( int ) code ;  } else { cur_str . the_string = translation_table [ code - 256 ]  -> the_string ; cur_str . character =  - 1 ;  }  } void addto_translation_table ( tt_entry_t *  * translation_table , tt_entry_t * tt_entries , const tt_entry_t & new_string , unsigned long & string_num )  { translation_table [ string_num ]  =  & tt_entries [ string_num ]  ; tt_entries [ string_num ]  = new_string ; string_num ++  ;  } int lzw_decompress ( tt_entry_t *  * translation_table , tt_entry_t * tt_entries , unsigned char * in_data_buffer , unsigned long code_num , unsigned char * out_data_buffer , unsigned long * out_data_len )  { enum { STA_STRING = 8 , STA_CHAR = 9 ,  }  ; int ret_val =  - 1 ; unsigned long cur_pos , byte_offset , old_byte_offset , bit_offset ; unsigned short old_code , new_code , old_state ; tt_entry_t tmp_string ; translated_string_t cur_string ; unsigned long string_num ; unsigned char character ; unsigned long tmp_var ; tt_entry_t *  * tmp_ptr1 = NULL ,  * tmp_ptr2 = NULL ; int flag ; if (  ! translation_table )  { tmp_ptr1 = new tt_entry_t *  [ MAX_ST_ENTRIES ]  ; if (  ! tmp_ptr1 )  { goto err_out ;  } translation_table = tmp_ptr1 ;  } if (  ! tt_entries )  { tmp_ptr2 = new tt_entry_t [ MAX_ST_ENTRIES ]  ; if (  ! tmp_ptr2 )  { goto err_out ;  } tt_entries = tmp_ptr2 ;  } memset ( translation_table , 0 , sizeof ( tt_entry_t *  )  * MAX_STR_NUM )  ; memset ( tt_entries , 0 , sizeof  ( tt_entry_t )  * MAX_ST_ENTRIES )  ; bit_offset = 0 ; read_data_from_bs (  ( unsigned char *  )  & old_code , CODE_LENGTH , in_data_buffer , bit_offset )  ; assert ( old_code < 256 )  ; dbg_print ( "byte offset=0, code=%d, string length=1\n" , old_code )  ; out_data_buffer [ 0 ]  =  ( unsigned char ) old_code ; character =  ( unsigned char ) old_code ; string_num = 0 ; byte_offset = 1 , old_state = STA_CHAR , old_byte_offset = 0 ; for ( cur_pos = 1 ; cur_pos < code_num ; cur_pos ++  )  { dbg_print ( "byte offset=%d, " , byte_offset )  ; if ( byte_offset == 1947 )  { byte_offset = byte_offset ;  } read_data_from_bs (  & new_code , CODE_LENGTH , in_data_buffer , bit_offset )  ; tmp_var = byte_offset ; if ( search_translation_table ( translation_table , new_code )  < 0 )  { translate_code ( translation_table , old_code , cur_string )  ; flag = 0 ; tmp_string . the_string . start_pos =  ( unsigned short ) byte_offset ; tmp_string . the_string . str_len =  (  - 1 == cur_string . character ? cur_string . the_string . str_len + 1 : 2 )  ; old_state = STA_STRING ;  } else { tmp_string . the_string . start_pos =  ( unsigned short ) old_byte_offset ; if ( STA_CHAR == old_state )  { tmp_string . the_string . str_len = 2 ;  } else if ( STA_STRING == old_state )  { tmp_string . the_string . str_len = translation_table [ old_code - 256 ]  -> the_string . str_len + 1 ;  } else { assert ( 0 )  ;  } translate_code ( translation_table , new_code , cur_string )  ; flag = 1 ; old_state =  - 1 != cur_string . character ? STA_CHAR : STA_STRING ;  } if (  - 1 == cur_string . character )  { memcpy ( out_data_buffer + byte_offset , out_data_buffer + cur_string . the_string . start_pos , cur_string . the_string . str_len )  ; byte_offset += cur_string . the_string . str_len ;  } else { out_data_buffer [ byte_offset ]  =  ( unsigned char  ) cur_string . character ; byte_offset ++  ;  } if ( 0 == flag )  { out_data_buffer [ byte_offset ]  = character ; byte_offset ++  ;  } character =  (  - 1 == cur_string . character ? out_data_buffer [ cur_string . the_string . start_pos ]  :  ( unsigned char ) cur_string . character )  ; dbg_print ( "code=%d, string length=%d\n" , new_code , 0 == flag ? tmp_string . the_string . str_len :  - 1 == cur_string . character ? cur_string . the_string . str_len : 1 )  ; addto_translation_table ( translation_table , tt_entries , tmp_string , string_num )  ; old_code = new_code ; old_byte_offset = tmp_var ;  } assert ( bit_offset == code_num * CODE_LENGTH )  ;  * out_data_len = byte_offset ; ret_val = 0 ; err_out : if ( tmp_ptr1 )  { delete [  ] tmp_ptr1 ;  } if ( tmp_ptr2 )  { delete [  ] tmp_ptr2 ;  } return ret_val ;  } int Lzwc ( char * src_file , char * dest_file )  { int ret_val =  - 1 ; unsigned char data_buff [ MAX_CB_ONECE ]  ; unsigned char compressed_data_buff [  ( MAX_CB_ONECE * CODE_LENGTH )  / 8 ]  ; int xx ; FILE * fp_src = NULL ,  * fp_dest = NULL ; unsigned long total_bytes_to_compress , bytes_to_compress , bits_compressed ; int rc ; fp_src = fopen ( src_file , "rb" )  ; if (  ! fp_src )  { goto err_out ;  } fp_dest = fopen ( dest_file , "wb" )  ; if (  ! fp_dest )  { goto err_out ;  } fseek ( fp_src , 0 , SEEK_END )  ; total_bytes_to_compress = ftell ( fp_src )  ; fseek ( fp_src , 0 , SEEK_SET )  ; do { lzw_info_t lzwinfo ; bytes_to_compress = total_bytes_to_compress > MAX_CB_ONECE ? MAX_CB_ONECE : total_bytes_to_compress ; fread ( data_buff , 1 , bytes_to_compress , fp_src )  ; rc = lzw_compress ( lzw_string_table , lzw_string_table_entries , data_buff , bytes_to_compress , compressed_data_buff ,  & bits_compressed )  ; if ( RCFAILED == rc )  { goto err_out ;  } else { if ( RCOK_DATA_UNC == rc )  { lzwinfo . code_num =  ( unsigned long )  ( bits_compressed / 8 )  ; lzwinfo . data_compressed = 0 ;  } else if ( RCOK_DATA_COM == rc )  { lzwinfo . code_num =  ( unsigned long )  ( bits_compressed / CODE_LENGTH )  ; lzwinfo . data_compressed = 1 ;  } fwrite (  & lzwinfo , 1 , sizeof ( lzw_info_t )  , fp_dest )  ; fwrite ( compressed_data_buff , 1 ,  ( bits_compressed + 7 )  / 8 , fp_dest )  ; total_bytes_to_compress -= bytes_to_compress ;  }  } while ( total_bytes_to_compress > 0 )  ; ret_val = 0 ; err_out : if ( fp_src )  { fclose ( fp_src )  ;  } if ( fp_dest )  { fclose ( fp_dest )  ;  } return ret_val ;  } int Lzwd ( char * src_file , char * dest_file )  { int ret_val =  - 1 ; unsigned char data_buff [ MAX_CB_ONECE ]  ; unsigned char compressed_data_buff [  ( MAX_CB_ONECE * CODE_LENGTH )  / 8 ]  ; FILE * fp_src = NULL ,  * fp_dest = NULL ; unsigned long bytes_decompressed , file_size , file_pos ; fp_src = fopen ( src_file , "rb" )  ; if (  ! fp_src )  { goto err_out ;  } fp_dest = fopen ( dest_file , "wb" )  ; if (  ! fp_dest )  { goto err_out ;  } fseek ( fp_src , 0 , SEEK_END )  ; file_size = ftell ( fp_src )  ; fseek ( fp_src , 0 , SEEK_SET )  ; file_pos = 0 ; while ( 1 )  { lzw_info_t lzwinfo ; unsigned long bytes_to_read ; if ( file_pos >= file_size )  { break ;  } fread (  & lzwinfo , 1 , sizeof ( lzwinfo )  , fp_src )  ; file_pos += sizeof ( long )  ; if ( file_pos >= file_size )  { break ;  } if ( lzwinfo . data_compressed )  { bytes_to_read =  (  ( unsigned long ) lzwinfo . code_num * CODE_LENGTH + 7 )  / 8 ;  } else { bytes_to_read =  ( unsigned long ) lzwinfo . code_num ;  } fread ( compressed_data_buff , 1 , bytes_to_read , fp_src )  ; file_pos += bytes_to_read ; if ( lzwinfo . data_compressed )  { lzw_decompress ( lzw_translation_table , lzw_translation_table_entries , compressed_data_buff ,  ( unsigned long ) lzwinfo . code_num , data_buff ,  & bytes_decompressed )  ;  } else { memcpy ( data_buff , compressed_data_buff , bytes_to_read )  ; bytes_decompressed = bytes_to_read ;  } fwrite ( data_buff , 1 , bytes_decompressed , fp_dest )  ;  } ret_val = 0 ; err_out : if ( fp_src )  { fclose ( fp_src )  ;  } if ( fp_dest )  { fclose ( fp_dest )  ;  } return ret_val ;  } static N = 0 ; int Lzwc_test ( char * src_file , char * dest_file )  { int ret_val =  - 1 ; unsigned char data_buff [ MAX_CB_ONECE ]  ; unsigned char compressed_data_buff [  ( MAX_CB_ONECE * CODE_LENGTH )  / 8 ]  ; FILE * fp_src = NULL ,  * fp_dest = NULL ; unsigned long bits_compressed ; fp_src = fopen ( src_file , "rb" )  ; if (  ! fp_src )  { goto err_out ;  } fp_dest = fopen ( dest_file , "wb" )  ; if (  ! fp_dest )  { goto err_out ;  } do { lzw_info_t lzwinfo ; int rc ; fseek ( fp_src , N * MAX_CB_ONECE , SEEK_SET )  ; fread ( data_buff , 1 , MAX_CB_ONECE , fp_src )  ; FILE * fp_tmp = fopen ( "test.tmp" , "wb" )  ; fwrite ( data_buff , 1 , MAX_CB_ONECE , fp_tmp )  ; fclose ( fp_tmp )  ; rc = lzw_compress ( lzw_string_table , lzw_string_table_entries , data_buff , MAX_CB_ONECE , compressed_data_buff ,  & bits_compressed )  ; if ( RCFAILED == rc )  { goto err_out ;  } else { if ( RCOK_DATA_UNC == rc )  { lzwinfo . code_num =  ( unsigned long )  ( bits_compressed / 8 )  ; lzwinfo . data_compressed = 0 ;  } else if ( RCOK_DATA_COM == rc )  { lzwinfo . code_num =  ( unsigned long )  ( bits_compressed / CODE_LENGTH )  ; lzwinfo . data_compressed = 1 ;  } fwrite (  & lzwinfo , 1 , sizeof ( lzw_info_t )  , fp_dest )  ; fwrite ( compressed_data_buff , 1 ,  ( bits_compressed + 7 )  / 8 , fp_dest )  ;  }  } while ( 0 )  ; ret_val = 0 ; err_out : if ( fp_src )  { fclose ( fp_src )  ;  } if ( fp_dest )  { fclose ( fp_dest )  ;  } return ret_val ;  } int main ( int argc , char * argv [  ]  )  { int ret_val ; if ( 4 != argc )  { printf ( "Usage: Lzw [/c | /d] <source file> <destination file>\n" )  ; return - 1 ;  } unsigned long t1 , t2 ; t1 = GetTickCount (  )  ; if ( 'c/' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'C/' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'c-' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'C-' ==  *  ( unsigned short *  ) argv [ 1 ]  )  { printf ( "Compressing..." )  ; ret_val = Lzwc ( argv [ 2 ]  , argv [ 3 ]  )  ;  } if ( 'd/' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'D/' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'd-' ==  *  ( unsigned short *  ) argv [ 1 ]  || 'D-' ==  *  ( unsigned short *  ) argv [ 1 ]  )  { printf ( "Decompressing..." )  ; ret_val = Lzwd ( argv [ 2 ]  , argv [ 3 ]  )  ;  } t2 = GetTickCount (  )  ; if ( 0 == ret_val )  { printf ( "Successfully!\n" )  ; printf ( "%ld milliseconds elapsed\n" , t2 - t1 )  ;  } else { printf ( "Failed!\n" )  ;  } return ret_val ;  } 